%The document's type
\documentclass[a4paper,11pt]{article}

%Additionnal packages
\usepackage{color}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{indentfirst}


%%%%%%%%%% Start TeXmacs macros
\newcommand{\tmbsl}{\ensuremath{\backslash}}
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmstrong}[1]{\textbf{#1}}
\newcommand{\tmtexttt}[1]{{\ttfamily{#1}}}
\definecolor{grey}{rgb}{0.75,0.75,0.75}
\definecolor{orange}{rgb}{1.0,0.5,0.5}
\definecolor{brown}{rgb}{0.5,0.25,0.0}
\definecolor{pink}{rgb}{1.0,0.5,0.5}
%%%%%%%%%% End TeXmacs macros

\title{Market microstructure simulation library Marketsim\\Overview}
\author{Anton Kolotaev}

\begin{document}

\maketitle

\tableofcontents



















\newpage

\section{Installation}\label{installation}

For the moment the simulator has two user interfaces:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \textbf{Web}. A user runs a simulation server and uses a web interface
  to set up model parameters and run the simulation.
\item
  \textbf{Veusz}. A user edits script files describing a simulation, run
  a simulator and the results are rendered using Veusz software (in
  principle, it quite easy to plug in another means of visualization).
\end{itemize}

The first approach is easier for new users while the latter one gives
more control over simulation.

\subsection{Installing Scala}\label{installing-scala}

The simulator uses a code generated by a translator from Strategy
Definition Language. This translator is implemented in Scala progamming
language. 

The easiest way to install Scala is to install Simple Build Tool (SBT)
from
\url{http://www.scala-sbt.org/release/docs/Getting-Started/Setup.html}

At Ubuntu SBT may be installed in the following way:

\begin{verbatim}
wget http://apt.typesafe.com/repo-deb-build-0002.deb
sudo dpkg -i repo-deb-build-0002.deb
sudo apt-get update
sudo apt-get install sbt
\end{verbatim}

After having installed SBT you may check does it work by typing
\texttt{sbt run} in \texttt{\$(MARKETSIM\_PATH)/marketsim/gen}
directory. This will download Scala 2.10 distribution and additional
packages. If everything is fine \texttt{sbt run} repeated one more time
will print something like:

\begin{verbatim}
parsing...done
building name tables...
    removing anonymous packages
    injecting base packages
    removing abstract packages
    applying before typing annotations
done
typing...done
generating python code...done
\end{verbatim}

Note that installing Scala is required only if strategy descriptions are
going to be edited.

\subsection{Steps common for Veusz and Web
interfaces}\label{steps-common-for-veusz-and-web-interfaces}

Latest public version of the simulator can be downloaded from
\url{https://github.com/fiquant/marketsimulator/releases}

This version of the simulator requires Python 2.7 installed:
\url{http://www.python.org/download/}

Following Python packages need to be installed:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{blist}: \url{https://pypi.python.org/pypi/blist/}
\item
  \texttt{docutils}: \url{https://pypi.python.org/pypi/docutils} (only
  needed to run Web server)
\item
  \texttt{numpy}: \url{https://pypi.python.org/pypi/numpy} (only needed
  for \texttt{strategy.MultiArmedBandit})
\item
  \texttt{pandas}: \url{http://pandas.pydata.org/} (only needed for
  \texttt{Quotes} at the moment)
\end{itemize}

Normally all these packages can be downloaded and installed using
\texttt{pip} (\url{http://www.pip-installer.org/}) or
\texttt{easy\_install} (\url{https://pypi.python.org/pypi/setuptools})

\subsection{Running a Web-server with online
interface}\label{running-a-web-server-with-online-interface}

In order to run the web server you need \texttt{Flask} package
installed: \url{http://flask.pocoo.org/}

\texttt{wsgi/flaskapp.py} launches the Web server at default port 80:

After that you may open \texttt{localhost} page in your Web browser:

\centerline{\includegraphics[width=13cm]{Figures/web/traders.png}}

Press \textbf{Run} button to launch the simulation:

\centerline{\includegraphics[width=13cm]{Figures/web/volume-levels.png}}

\subsection{Offline usage with Veusz}\label{offline-usage-with-veusz}

For running scripts and offline visualisation \texttt{Veusz} package is
needed: \url{http://home.gna.org/veusz/}. After having it installed
\texttt{VEUSZ\_EXE} environment variable should be assigned to the path
to the Veusz executable. Afterwards, sample simulations may be launched:

\centerline{\includegraphics[width=13cm]{Figures/veusz/dependency.png}}

\section{Evolution of the simulator}\label{evolution-of-the-simulator}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Initial
  \href{http://sourceforge.net/p/marketsimulator/svn/HEAD/tree/Simulator/}{C++
  version} was developed in 2009-2011 by Riadh Zaatour.
\item
  In order to improve its extensibility and performance the simulator
  was \href{https://github.com/antonkolotaev/v2}{rewritten} using C++
  template metaprogramming techniques by
  \href{https://github.com/antonkolotaev}{Anton Kolotaev} in 2012.
  Python bindings to it were implemented using Boost.Python.
  Unfortunately the price for providing high extensibility with no
  overhead was quite high: in order to use it a proficiency in C++
  template metaprogramming was required.
\item
  A new pure Python version was designed and developed in 2013 by
  \href{https://github.com/antonkolotaev}{Anton Kolotaev}. The main idea
  of its design is representation of a simulation model as a composition
  of simple and compound modules. 
\item
  A web interface allowing to set up model parameters and launch the
  simulation was developed by
  \href{https://github.com/antonkolotaev}{Anton Kolotaev} in JavaScript
  using \href{http://knockoutjs.com/}{KnockoutJs} as MVVM framework and
  \href{http://www.highcharts.com/products/highstock}{Highstock} as
  graph visualisation library.
\item
  \href{https://github.com/koalainparis}{Karol Podkanski} has
  implemented number of trading strategies and indicators during his
  internship at summer 2013 (initial implementation for Relative
  Strength Index, Bollinger Bands, Market Data and Market Maker
  strategies, StopLoss meta order, statistical indicators and adaptors
  for existing statistics packages:
  \href{http://pandas.pydata.org/}{pandas} and
  \href{http://ta-lib.org/}{ta-lib})
\end{enumerate}

A dedicated language for module abstract description is developed.
A compiler from this language generates Python implementations for
compound modules and also all meta information about available modules
needed for the Web interface. It will be possible to edit code in this
dedicated language online thus making the Web interface powerful as the
offline version. An optimized C++ implementation for compound modules
will be generated automatically.

\section{Discrete event simulation
components}\label{discrete-event-simulation-components}

The main class for every discrete event simulation system is a scheduler
that maintains a set of actions to fulfill in future and launches them
according their action times: from the older ones to newer ones. The
scheduler in the simulator is implemented as a heap data structure in
order to perform frequent operations very fast. A classical heap allows
inserts into at O(logN), extracting the best element at O(logN) and
accessing to the best element at O(1). A bucket-based implementation may
be introduced in order to improve performance provided that the
distribution of event times should be known beforehand.

\subsection{Scheduler}\label{scheduler}

\texttt{Scheduler} class provides following interface:
\begin{verbatim}
class Scheduler(object):

    # cleans up event queue and resets simulation time to 0
    def reset(self)

    @property
    def currentTime(self)

    # schedules an event given by 'handler' to be launched at 'actionTime'
    def schedule(self, actionTime, handler)

    # schedules an event given by 'handler' to be launched after 'dt' from now
    def scheduleAfter(self, dt, handler):
        self.schedule(self.currentTime + dt, handler)

    # runs 'handler' asynchronously
    def async(self, handler):
        self.scheduleAfter(0, handler)

    # Launches all events with action time in range [currentTime, limitTime)
    # in order of their action time and arrival order
    def workTill(self, limitTime)

    # Makes the scheduler work 'dt' moments of time more
    def advance(self, dt)
        self.workTill(self.currentTime + dt)
\end{verbatim}

In order to schedule an event a user should use \texttt{schedule} or
\texttt{scheduleAfter} methods passing there an event handler which
should be given as a callable object (a function, a method, a lambda
expression or an object exposing \texttt{\_\_call\_\_} method).

Methods \texttt{workTill} and \texttt{advance} advance model time
calling event handlers in order of their action times. If two events
have same action time it is garanteed that the event scheduled first
will be executed first. These methods must not be called from an event
handler. In such a case an exception will be issued.

Components willing to have an access to the scheduler should acquire a
reference to it at binding time:

\begin{verbatim}
def bind(self, ctx):
    self._scheduler = ctx.world
\end{verbatim}

\subsection{Convenience classes}\label{convenience-classes}

There are several classes granting convenient access to the scheduler
and thus removing need for explicit binding against \texttt{ctx.world}.

\subsubsection{Current simulation time}\label{current-simulation-time}

For example,

\begin{verbatim}
(observable.CurrentTime() < 200)[Side.Sell, Side.Buy]
\end{verbatim}

returns \texttt{Side.Sell} if simulation time is less than 200 and
\texttt{Side.Buy} otherwise

\subsubsection{Generating events on regular
basis}\label{generating-events-on-regular-basis}

\texttt{event.Every} represents some repeating action. It is initialized
by a function defining interval of time to the next event invocation.

For example, sample path for a Poisson process with $\lambda$=1 can be obtained
in the following way:

\begin{verbatim}
from marketsim import mathutils, event, observable, _, ops

class CurrentTimePrinter(object):

    def __init__(self):
        self._currentTime = observable.CurrentTime()
        event.subscribe(event.Every(math.random.expovariate(1.)),
                        _(self)._print, self)

    _internals = ['_currentTime']

    def _print(self, _):
        print self._currentTime()
\end{verbatim}

when added to a simulation will print

\begin{verbatim}
0.313908407622
0.795173273046
1.50151801647
3.52280681834
6.30719707516
8.48277712333
\end{verbatim}

\subsubsection{Generating a single
event}\label{generating-a-single-event}

\texttt{event.After} generates a single event at some time in the
future.

\section{Events, functions and
observables}\label{events-functions-and-observables}

\subsection{Events}\label{events}
\textbf{Events} in the simultator are conceptually close to events in
C\# or \texttt{boost::signal} in C++. Number of listeners can be
subscribed for event notification using \texttt{+=} operator and
unsubscribed with \texttt{-=} operator. A listener should be a callable
object that accepts a single argument - the source of the event (it
allows not to store an event source in the listener and also use a
single listener for several event sources at the same time).

\subsection{Event subscription}\label{event-subscription}

Since event subscription is often done at binding time and unadvising
should be done at dispose time \texttt{event.subscribe} helper function
was introduced to manage event subscription declaratively:

\begin{verbatim}
class ProgressPrinter(object):

  def __init__(self):
    event.subscribe(event.Every(ops.constant(10)), # event source to subscribe to
                    _(self)._wakeUp,               # event listener
                    self)

  def _wakeUp(self, _):
    print '.'   # prints . every 10 units of time
\end{verbatim}

\subsection{Event helpers}\label{event-helpers}

\texttt{event.After} and \texttt{event.Every} are used to represent a
single and a repeating action

\texttt{event.Array} is used when several event sources are to be
represented as a single event. For example,

\begin{verbatim}
event.Array([BestPrice(Asks(orderbook)), BestPrice(Bids(orderbook))])
\end{verbatim}

fires an event once bid or ask of \texttt{orderbook} has changed.

\subsection{Filtered events}\label{filtered-events}

Sometimes an event source (for example, price of an asset) has hundreds
subscribers who check is the event source is less or greater than some
value. In order to avoid excessive calls \texttt{event.LessThan} and
\texttt{event.GreaterThan} classes are introduced. Event sources detect
objects of these types and store them sorted in order to lookup relevant
listeners very quickly. For example,

\begin{verbatim}
observable.MidPrice(orderbook) += event.LessThan(100, listener)
\end{verbatim}

will call \texttt{listener} only if mid-price of the asset is less than
100.

\subsection{Functions and observables}\label{functions-and-observables}

\begin{description}
\item[Function]
Object with overloaded \texttt{\_\_call\_\_} operator that accepts no
arguments and returns a value of type \texttt{T}. Further we will refer
to the type of a function as \texttt{() -\textgreater{} T} or
\texttt{IFunction}.
\item[Observable]
Function notifying listeners about its value changes. Only piecewise
constant functions should be considered as observables. An arbitrary
function can transformed into observable by means of
\texttt{observable.OnEveryDt(dt, func)}.
\end{description}

Conceptually observable might be defined as

\begin{verbatim}
class IObservable[T] (IFunction[T], IEvent): ...
\end{verbatim}
\subsection{Basic observables}\label{basic-observables}

\begin{itemize}
\item
  \texttt{Constant{[}T{]}} / \texttt{None{[}T{]}} represent typed
  constant value or \texttt{None} value
\item
  Arithmetic operations (\texttt{Sum}, \texttt{Sub}, \texttt{Product},
  \texttt{Div}, \texttt{Mod}). If both arguments of the operation are
  observable the operation fires events about its value change and thus
  becomes an event itself. Functions overload operations \texttt{+},
  \texttt{-}, \texttt{*}, \texttt{-}, \texttt{\%} so they construct
  respective objects. For example,
  \texttt{(observable.AskPrice(orderbook) + observable.BidPrice(orderbook)) / 2}
  creates an observable that notifies about every change of the
  mid-price.
\item
  Logic operations (\texttt{Equal{[}T{]}}, \texttt{NotEqual{[}T{]}},
  \texttt{Less{[}T{]}}, \texttt{Greater{[}T{]}},
  \texttt{GreaterEqual{[}T{]}}, \texttt{LessEqual{[}T{]}}). If both
  arguments of the operation are observable the operation fires events
  about its value change and thus becomes an event itself. Functions
  overload operations \texttt{==}, \texttt{!=}, \texttt{\textgreater{}=}, \texttt{\textgreater{}}, \texttt{\textless{}}, \texttt{\textless{}=} so they construct
  respective objects. These operations inherit from
  \texttt{IFunction{[}bool{]}}/\texttt{IObservable{[}bool{]}} and have
  overloaded indexing operator that constructs \texttt{Condition{[}T{]}}
  object and it allows to write if-then-else expressions like:

\begin{verbatim}
# randomly chooses either Side.Buy or Side.Sell
(math.random.uniform(0.,1.) < 0.5)[ 
    ops.constant(Side.Buy), ops.constant(Side.Sell) 
]
\end{verbatim}
\item
  Functions from standard \texttt{math} module: \texttt{Atan},
  \texttt{Pow} etc
\item
  Random distributions from \texttt{random} module: \texttt{uniform},
  \texttt{lognormvariate}, \texttt{expovariate} etc.
\item
  \texttt{Derivative} of a differentiable function
\item
  \texttt{Lagged}: returns function values with some lag
\end{itemize}

\begin{verbatim}
Max(x,y) ::= if x > y then x else y
Min(x,y) ::= if x < y then x else y

Sqr(x) ::= x*x
\end{verbatim}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{Quotes}: downloads external historical data
\end{itemize}

There are also statistics related functions,
functions of orderbooks and of traders.

\section{Statistics}\label{statistics}

Statistical functions operate on paths of function values and in general
case it requires storing the function history and recalculating
statistics each time. Every recalculation has at least O(M) time
complexity where M is number of points involved and thus it is quite
time consuming.

Many statistical packages (like \href{http://pandas.pydata.org/}{pandas}
and \href{http://ta-lib.org/}{ta-lib}) provide a lot of useful functions
that work on time series and in order to facilate interoperability with
these libraries the market simulator provide handful adapters.

In some cases (moving average, moving variance etc) it is possible to
introduce an incremental version that make every update in constant time
and thus works much faster.

\subsection{Moving average}\label{moving-average}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  cumulative: \texttt{CMA}
\item
  simple moving: \texttt{MA(timeframe)}
\item
  exponentially weighted: \texttt{EWMA(alpha)}
\end{itemize}

\centerline{\includegraphics[width=13cm]{Figures/web/averages.png}}

\subsection{Moving average
convergence/divergence}\label{moving-average-convergencedivergence}

Having defined moving average we may introduce
\href{http://en.wikipedia.org/wiki/MACD}{moving average
convergence/divergence}, its signal and histogram
\begin{verbatim}
MACD(x, slow, fast) ::= 
    EWMA(x, 2./(fast+1)) - EWMA(x, 2./(slow+1))

MACD_signal(x, slow, fast, timeframe) ::= 
    EWMA(MACD(x, slow, fast), 2/(timeframe+1))

MACD_histogram(x, slow, fast, timeframe) ::= 
    MACD(x,slow,fast) - MACD_signal(x,slow, fast, timeframe)
\end{verbatim}

\centerline{\includegraphics[width=13cm]{Figures/web/macd.png}}

\subsection{Moving variance}\label{moving-variance}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  cumulative: \texttt{Variance}
\item
  moving: \texttt{MovingVariance(timeframe)}
\item
  exponentially weighted: \texttt{EWMV(alpha)}
\end{itemize}
Variances could be implemented via Mean but it looses precision so they
are implemented as simple modules

\begin{verbatim}
Var(x) ::= Mean(Sqr(x)) - Sqr(Mean(x))
\end{verbatim}

\subsection{Standard deviation}\label{standard-deviation}

\begin{verbatim}
StdDev(x) ::= Sqrt(Variance(x))
StdDevRolling(x, timeframe) ::= Sqrt(MovingVariance(x, timeframe))
StdDevEW(x, alpha) ::= Sqrt(EWMV(x, alpha))
\end{verbatim}

\subsection{Bollinger bands}\label{bollinger-bands}

Having moving averages and variances it is possible to find
\href{http://en.wikipedia.org/wiki/Bollinger_Bands}{bollinger bands}:

\begin{verbatim}
Bollinger_Hi(x) ::= Mean(x) + 2*StdDev(x)
Bollinger_Lo(x) ::= Mean(x) - 2*StdDev(x)
\end{verbatim}

\centerline{\includegraphics[width=13cm]{Figures/web/bollinger_bands.png}}

\subsection{Relative strength index}\label{relative-strength-index}

An observable returning values of a function with some lag
(\texttt{Lagged}) allows easily implement
\href{http://en.wikipedia.org/wiki/Relative_strength_index}{relative
strength index}:

\begin{verbatim}
Ups(x, dt, alpha) ::= 
    EWMA(max(0, x - Lagged(x, dt)), alpha) 
    --- moving average of positive movements
	
Downs(x, dt, alpha) ::= 
    EWMA(max(0, Lagged(x, dt) - x), alpha) 
    --- moving average of negative movements
	
RSI(x, dt, alpha) ::= 
    100 - 100 / (1 + Ups(x,dt,alpha)/Downs(x,dt,alpha))
\end{verbatim}
\centerline{\includegraphics[width=13cm]{Figures/web/rsi.png}}

\subsection{Moving minimum and maximum}\label{moving-minimum-and-maximum}
\centerline{\includegraphics[width=13cm]{Figures/web/minmax.png}}

\section{Elementary orders, their factories and
requests}\label{elementary-orders-their-factories-and-requests}

Traders send orders to a market. There are two basic kinds of orders:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \textbf{Market orders} ask to buy or sell some asset at any price.
\item
  \textbf{Limit orders} ask to buy or sell some asset at price better
  than some limit price. If a limit order is not competely fulfilled it
  remains in an order book waiting to be matched with another order.
\end{itemize}

An order book processes market and limit orders but keeps persistently
only limit ones. Limit orders can be cancelled by sending cancel
request.

From trader point of view there can be other order types like
Iceberg order but from order book
perspective it is just a sequence of basic orders and requests. They
will be considered at meta orders section.

Besides basic orders there are also requests: order cancellation
request, request to estimate market impact of a trade etc. Their
interface differs a lot from orders' interface that's why they are put
into a separate group.

\subsection{Market and limit orders}\label{market-and-limit-orders}

Market and limit orders (and some meta orders) derive from a common base
class that provides some basic functionality:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  matched/unmatched volume management
\item
  storing a cancellation flag
\item
  keeping a reference to the order's owner
\end{itemize}

It has following interface:

\begin{verbatim}
class order.Base(object):

    @property
    def volumeFilled(self)

    @property
    def volumeUnmatched(self)

    @property
    def volumeTotal(self):
        return self.volumeFilled + self.volumeUnmatched

    @property
    def empty(self):
        return self.volumeUnmatched == 0

    @property
    def side(self)

    @property
    def cancelled(self)

    def cancel(self)

    # owner who issued the order (trader, metaorder or proxy orderbook)
    # it will be notified about order's events
    @property
    def owner(self)
\end{verbatim}

Classes \texttt{order.Market} and \texttt{order.Limit} derive from this
class and define method \texttt{processIn(orderbook)} which defines how
the order should be processed in an orderbook.

When the order is matched against another order it calls
\texttt{onMatchedWith} method of the \texttt{owner} passing volume and
price at which the trade was done.

If an order is cancelled or gets completely matched
\texttt{onOrderDisposed} method of the \texttt{owner} is called.

Limit order defines also accessors to its price:

\begin{verbatim}
class order.Limit(order.Base):

    @property
    def price(self)

    # Returns "signed" price of the order:
    #       positive if the order is on sell side
    #       negative if the order is on buy side
    @property
    def signedPrice(self)
\end{verbatim}

\subsection{Order factories}\label{order-factories}

Components in the simulator creating orders (strategies, meta orders)
are parametrized by \emph{order factories}.

Order factories are initialized by functions calculating parameters of
order to create. For example,

\begin{verbatim}
class order.factory.Market(types.IOrderFactory):

    def __init__(self, side, volume):
        self.side = side            # () -> Side
        self.volume = volume        # () -> Volume

    _properties = {
        'side'   : IFunction[Side],
        'volume' : IFunction[Volume]
    }

    def __call__(self):
        side = self.side()
        if side is None: return None

        volume = self.volume()
        if volume is None: return None

        return order.Market(side, volume)
\end{verbatim}

If some parameters of an order to create depend on other parameters, a
special factory is provided. For example,

\begin{verbatim}
class order.factory.SignedMarket(types.IOrderFactory):

    def __init__(self, signedvolume):
        self.signedvolume = signedvolume

    _properties = {
        'signedvolume' : IFunction[int]
    }

    def __call__(self):
        signedvolume = self.signedvolume()
        if signedvolume in [None, 0]: return None

        return order.Market(signedvolume > 0 ? Side.Buy : Side.Sell,
                            abs(signedvolume))
\end{verbatim}

Sometimes order factories are constructed in several steps: for example,
some parameters of a factory are defined by a trading strategy and the
rest is defined by user.

In order to support these use cases order factories have also a curried
form. For example, \texttt{order.factory.volume.Market} has type
\texttt{(() -\textgreater{} Volume) -\textgreater{} IOrderGenerator} and
\texttt{order.factory.side\_price.Limit} has type
\texttt{(() -\textgreater{} Side) -\textgreater{} (() -\textgreater{} Price) -\textgreater{} IOrderGenerator}.

\subsection{Requests}\label{requests}

Requests query some information about an order book or instructs to do
something.

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{request.Cancel(order)} instructs an order book to cancel the
  \texttt{order}
\item
  \texttt{request.EvalMarketOrder(side, volume)} calculates cumulative
  price and volume of trades induced by a market order with given
  \texttt{side} and \texttt{volume}.
\item
  \texttt{request.EvalVolumesForBudget(side, budget)} calculates a
  sequence of prices and volumes of best orders in the order book with
  total price less or equal to \texttt{budget}.
\end{itemize}

These requests also have \texttt{callback} parameter used to pass
results of the request (so it is a continuation passing style, CPS).


\section{Market representation}\label{market-representation}

\begin{description}
\item[Order book]
Order book represents a single asset traded in some market. Same asset
traded in different markets would have been represented by different
order books. An order book stores unfulfilled limit orders sent for this
asset in two order queues, one for each trade sides (Asks for sell
orders and Bids for buy orders).
\item[Order queue]
Order queues are organized in a way to extract quickly the best order
and to place a new order inside. In order to achieve this a heap based
implementation is used. (A bucket based implementation might be also
used).
\item[Ticks]
Order books support a notion of a tick size: all limit orders stored in
the book should have prices that are multipliers of the chosen tick
size. If an order has a limit price not divisible by the tick size it is
rounded to the closest `weaker' tick (`floored' for buy orders and
`ceiled' for sell orders). In future all prices will be stored as
integers in ticks.
\item[Market order]
Market orders are processed by an order book in the following way: if
there are unfulfilled limit orders at the opposite trade side, the
market order is matched against them till either it is fulfilled or
there are no more unfilled limit orders. Price for the trade is taken as
the limit order limit price. Limit orders are matched in order of their
price (ascending for sell orders and descending for buy orders). If two
orders have the same price, it is garanteed that the elder order will be
matched first.
\item[Limit order]
Limit orders firstly processed exactly as market orders. If a limit
order is not filled completely it is stored in a corresponding order
queue.
\item[Order processing time]
Orders and requests are processed by an order book in serialized way. It
implies that, for example, if a meta order sends another order it is
garanteed that the latter will be processed only after the meta order is
completely processed. \texttt{ORDER\_PROCESSING\_TIME} defines how much
time every order or request should be processed (in future, it might be
replaced by a function)
\item[Transaction costs]
There is a notion of transaction costs: if a user wants to define
functions computing transaction fees for market, limit and cancel orders
she should pass functions of form
\texttt{(anOrder, orderBook) -{}-\textgreater{} Price} to the order book
constructor. If \texttt{Price} is negative, the trader gains some money
on this transaction. If the functions are given, once an order is
processed by an order book, method \texttt{order.charge(price)} is
called. The default implementation for the method delegates it to
\texttt{trader.charge(price)} where \texttt{trader} is a trader
associated with the \texttt{order}.
\end{description}

\subsection{Order book}\label{order-book}

For the moment, there are two kinds of order books: local and remote
ones. Local order books execute their methods immediately but remote
ones try to simulate some delay between a trader and a market by means
of message passing (so they are asynchronous by their nature). These
books try to have the same interface in order that traders couldn't tell
the difference between them.

The base class for the order books is:

\begin{verbatim}
class orderbook.BookBase(object):
    def __init__(self, tickSize=1, label="")
    def tickSize(self)
    def process(self, orderOrRequest)
    def bids(self)
    def asks(self)
\end{verbatim}

\subsection{Local order book}\label{local-order-book}

Local order books extend the base order book by concrete order
processing implementation (methods \texttt{processLimitOrder},
\texttt{cancelOrder}, etc.) and allow user to define functions computing
transaction fees:

\begin{verbatim}
class orderbook.Local(BookBase):
    """ Order book for a single asset in a market
    Maintains two order queues for orders of different sides
    """
    def __init__(self, tickSize=1, label="",
                 marketOrderFee = None,
                 limitOrderFee = None,
                 cancelOrderFee = None)

def cancelOrder(self, order)

# Evaluates price at which a market order of given 'side' 
# and having given 'volume' would be executed
def evaluateOrderPrice(self, side, volume)

def evaluateOrderPriceAsync(self, side, volume, callback):
    callback(self.evaluateOrderPrice(side, volume))

# returns list of (price, volume) of trades that might be done for given 'budget'
def evaluateVolumesForBudget(self, side, budget, callback)

def processLimitOrder(self, order)
def processMarketOrder(self, order)
\end{verbatim}

\subsection{Order queue}\label{order-queue}

Order queues can be accessed via \texttt{queue}, \texttt{asks} and
\texttt{bids} methods of an order book and provide following user
interface:

\begin{verbatim}
class orderbook.Queue(object):
    def __init__(self, ...):
        self.lastTrade = LastTrade() # observable updating after each trade
        self.bestPrice = BestPrice(self) # observable with price of the best order

    # Enumerates orders in order of their price
    # Enumeration best M orders requires O(MlogM) operations
    @property
    def sorted(self)

    # Enumerates (price, volume) cumulative volumes for every price in the queue
    @property
    def sortedPVs(self)

    # Evaluates price for a potential market order with given 'volume'
    # Returns pair (price, volume_unmatched) where 'volume_unmatched' may be positive
    # if there is not enough volume in the order queue
    # Complexity of the operation: O(MlogM) where M - number of orders involved
    def evaluateOrderPrice(self, volume)

    # Returns prices of the order at depths given by 'volumes'
    def getVolumePrices(self, volumes)

    # Enumerates orders with price better than or equal to 'limit'
    def withPricesBetterThan(self, limit, idx=0)

    # Returns total volume of orders having price better than or equal to 'limit'
    def volumeWithPriceBetterThan(self, limit)

    # Returns (price, volume) for limit orders to be placed
    # in order to buy or sell assets on total *budget*
    def pvsForFixedBudget(self, budget)
\end{verbatim}

\subsection{Remote order book}\label{remote-order-book}

Remote order book (\texttt{orderbook.Remote} class) represents an order
book for a remote trader. Remoteness means that there is some delay
between moment when an order is sent to a market and the moment when the
order is received by the market so it models latency in
telecommunication networks. A remote book constructor accepts a
reference to an actual order book (or to another remote order book) and
a reference to a two-way communication channel.

Class \texttt{remote.TwoWayLink} implements a two-way telecommunication
channel having different latency functions in each direction (to market
and from market). It also ensures that messages are delivired to the
recipient in the order they were sent.

Queues in a remote book are instances of
\texttt{orderbook.\_remote.Queue} class. This class is connected to the
real order queue and listens \texttt{bestPrice} events thus keeping
information about the best order in the queue up-to-date. When a remote
order book receives an order, it is cloned and sent to the actual order
book via a communication link. The remote order book gets subscribed to
the clone order's events via downside link. It leads to that in some
moments of time the state of the original order and its clone are not
synchronised (and this is normal).

In future a mechanism to query underlying order book capabilities (for
example, can it process meta orders by himself) will be introduced thus
allowing to model meta order processing at client/broker/market side.

\section{Simple strategies}\label{simple-strategies}

\texttt{Generic(eventGen, orderFactory)} wakes up at moments of time
given by \texttt{eventGen} and asks \texttt{orderFactory} to create an
order.

For example, a crossing averages strategy that sends market orders with
exponentially distributed volume sizes in even intervals of time could
be written as:

\begin{verbatim}
strategy.Generic(event.Every(constant(1.)),
        order.factory.Market(
            side = parts.side.TwoAverages(
                                MidPrice(orderbook.OfTrader()),
                                alpha1, alpha2),
            volume = rnd.Expovariate(1.)
       ))
\end{verbatim}

There are also handy specialisations of this generic strategy. Usually
they accept parameters defining strategy logic and an order factory in a
curried form.

\subsection{Liquidity provider
strategy}\label{liquidity-provider-strategy}

Liquidity provider strategy (\texttt{strategy.LiquidityProvider} class)
is an array of two strategies providing liquidity for each side of trade
over the asset (\texttt{strategy.LiquidityProviderSide}). Every
\texttt{strategy.LiquidityProviderSide} wakes up at moments of time
given by \texttt{eventGen}, calculates a base price of the asset (it is
taken as price of the best order in the queue, if none, price of the
last trade is taken, if none we take some default value). Then an order
with price equal to the base price multiplied by a value taken from
\texttt{priceDistr} and volume taken from \texttt{volumeDistr} is
created.

\begin{verbatim}
NotNone(x, defaultValue) ::=
    if x == None then defaultValue else x

price.LiquidityProviderSide(orderqueue, priceDistr, defaultValue) ::=
    priceDistr * (NotNone(BestPrice(orderqueue),
                     NotNone(LastTradePrice(orderqueue),
                         defaultValue))

strategy.LiquidityProviderSide(eventGen, orderFactory, 
                               side, priceDistr, defaultValue) ::=
        orderbook = orderbook.OfTrader() in
        strategy.Generic(eventGen,
                         orderFactory(ops.constant(side),
                                      price.LiquidityProviderSide(
                                        orderbook.queue(side),
                                        priceDistr,
                                        defaultValue)))

strategy.LiquidityProvider(eventGen, orderFactory, priceDistr, defaultValue) ::=
    strategy.Array([
            strategy.LiquidityProviderSide(eventGen, orderFactory, 
                                           Side.Sell, priceDistr, defaultValue),
            strategy.LiquidityProviderSide(eventGen, orderFactory, 
                                           Side.Buy,  priceDistr, defaultValue),
    ])
\end{verbatim}
\subsection{Noise strategy}\label{noise-strategy}

Noise strategy wakes up at moments of time given by \texttt{eventGen}
and chooses randomly trade side.

\begin{verbatim}
side.Random() ::=
    if uniform(0,1) > 0.5 then Side.Sell else Side.Buy

strategy.Noise(eventGen, orderFactory) ::=
    strategy.Generic(eventGen, orderFactory(side.Random()))
\end{verbatim}

\subsection{Signal strategy}\label{signal-strategy}

Signal strategy listens to some discrete \texttt{signal} and when the
signal becomes more than some \texttt{threshold} the strategy starts to
buy. When the signal gets lower than \texttt{-threshold} the strategy
starts to sell.

\begin{verbatim}
side.Signal(x, threshold) ::=
    if  x > threshold then Side.Buy else
    if -x > threshold then Side.Sell else
    None

strategy.Signal(eventGen, orderFactory, signal, threshold) ::=
    strategy.Generic(eventGen, orderFactory(
        side.Signal(signal, threshold)))
\end{verbatim}

\centerline{\includegraphics[width=13cm]{Figures/web/signal.png}}

\subsection{Trend follower}\label{trend-follower}

Trend follower can be considered as a sort of a signal strategy where
the \texttt{signal} is a trend of the asset's price. Under trend we
understand the first derivative of some moving average. If the
derivative is positive, the trader buys; if the derivative is negative,
it sells. Since a moving average is a continuously changing signal, we
check its derivative at moments of time given by \texttt{eventGen}.

\begin{verbatim}
side.TrendFollower(price, alpha) ::=
    side.Signal(Derivative(EWMA(price, alpha)), 0)

strategy.TrendFollower(eventGen, orderFactory, alpha) ::=
    strategy.Generic(eventGen, orderFactory(
            side.TrendFollower(observable.MidPrice(), alpha)))
\end{verbatim}


\centerline{\includegraphics[width=13cm]{Figures/web/trendfollower.png}}

\subsection{Crossing averages
strategy}\label{crossing-averages-strategy}

Crossing averages strategy can be considered as a sort of a signal
strategy where the \texttt{signal} is a difference between two moving
averages of the asset's price.

\begin{verbatim}
side.TwoAverages(price, alpha1, alpha2) ::=
    side.Signal(EWMA(price, alpha1) - EWMA(price, alpha2), 0)

    strategy.TwoAverages(eventGen, orderFactory, alpha1, alpha2) ::=
            strategy.Generic(eventGen, orderFactory(
                    side.TwoAverages(observable.MidPrice(), alpha1, alpha2)))
\end{verbatim}

\centerline{\includegraphics[width=13cm]{Figures/web/twoaverages.png}}

\subsection{Fundamental value
strategy}\label{fundamental-value-strategy}

Fundamental value strategy believes that an asset should cost some
specific price (\texttt{fundamental value}) and if current asset price
is lower than the fundamental value it starts to buy the asset and if
the price is higher than the fundamental value it starts to sell the
asset.

\begin{verbatim}
side.FundamentalValue(orderbook, fv) ::=
    if BestPrice(Asks(orderbook)) < fv then Side.Buy else
    if BestPrice(Bids(orderbook)) > fv then Side.Sell else
    None

strategy.FundamentalValue(eventGen, orderFactory, fv) ::=
            strategy.Generic(eventGen, orderFactory(
                    side.FundamentalValue(orderbook.OfTrader(), fv)))
\end{verbatim}

\centerline{\includegraphics[width=13cm]{Figures/web/fundamentalvalue.png}}

\subsection{Mean reverting strategy}\label{mean-reverting-strategy}

Mean reverting strategy is a kind of a fundamental value strategy with
\texttt{fundamentalValue} equal to a moving average of the asset's
price.

\begin{verbatim}
side.MeanReverting(orderbook, alpha) ::=
    side.FundamentalValue(orderbook, EWMA(MidPrice(orderbook), alpha))

strategy.MeanReverting(eventGen, orderFactory, alpha) ::=
    strategy.Generic(eventGen, orderFactory,
        side.MeanReverting(orderbook.OfTrader(), alpha))
\end{verbatim}

\centerline{\includegraphics[width=13cm]{Figures/web/meanreversion.png}}

\subsection{Dependency trading
strategy}\label{dependency-trading-strategy}

Dependent price strategy believes that the fair price of an asset
\texttt{A} is completely correlated with price of another asset
\texttt{B} and the following relation should be held:
\texttt{Price(A) = k*Price(B)}, where \texttt{k} is some factor. It may
be considered as a variety of a fundamental value strategy.

\begin{verbatim}
side.Dependency(orderbook, otherOrderbook, factor) ::=
    side.FundamentalValue(orderbook, MidPrice(otherOrderbook) * factor)

strategy.Dependency(eventGen, orderFactory, otherOrderBook, factor) ::=
    strategy.Generic(eventGen, orderFactory(
            side.Dependency(orderbook.OfTrader(), otherOrderBook, factor)))
\end{verbatim}

\centerline{\includegraphics[width=13cm]{Figures/web/dependency.png}}

\subsection{Desired position
strategies}\label{desired-position-strategies}

These strategies keep track of the trader's position (actual position +
pending orders volume) and if \texttt{desiredVolume} changes it creates
orders in order to cover the gap between the current and the desired
position.

\begin{verbatim}
signed_volume.DesiredPosition(trader, desiredPosition) ::=
        desiredPosition - VolumeTraded(trader) - VolumePending(trader)
\end{verbatim}

\subsection{Bollinger bands strategy}\label{bollinger-bands-strategy}

Bollinger band strategy believes that a trader should take a position
equal to the difference between the current asset price and its average
divided on its standard deviation (and scaled by some \texttt{factor}).

\begin{verbatim}
signed_volume.BollingerBands(alpha, k) ::=
    trader = thisTrader(),
    price  = MidPrice(orderbook.OfTrader(trader)),
    mean   = EWMA(price, alpha),
    stddev = StdDevEW(price, alpha) in

    signed_volume.DesiredPosition(trader, (price - mean) / stddev * k)
\end{verbatim}

\subsection{Relative Strength Index
strategy}\label{relative-strength-index-strategy}

Relative Strength Index strategy believes that a trader should take a
position equal to deviation of its relative strength index from 50
scaled by some \texttt{factor}.

\begin{verbatim}
signed_volume.RSI(alpha, k, timeframe) ::=
    trader = thisTrader()
    rsi = RSI(orderbook.OfTrader(trader), timeframe, alpha) in
    signed_volume.DesiredPosition(trader, OnEveryDt(1, (50 - rsi) * k))
\end{verbatim}

\subsection{Market data strategy}\label{market-data-strategy}

This strategy allows to drive the asset price based on historical market
data by creating large volume orders for the given price. Every time
step of 1 time unit in the simulation corresponds to a 1 day in the
market data. At each time step the previous Limit Buy/Sell orders are
cancelled and new ones are created based on the next price of the market
data.

It is implemented as a strategy that wakes up once and create a
composition of iceberg and floating price orders. The floating price is
equal to the current quote plus/minus some delta and the iceberg order
breaks an `infinite' limit order into small lots.

\section{Adaptive strategies}\label{adaptive-strategies}

Adaptive strategies aggregate one or several other strategies and
control their execution (e.g. suspending/resuming it) depending on some
factors (e.g. efficiency estimation).

Class \texttt{strategy.Suspendable(strategy, predicate)} wraps
\texttt{strategy} and passes its orders further only if the observable
\texttt{predicate} evaluates to true.

There are many ways to estimate a strategy efficiency. First, we need to
associate with a strategy some kind of an account to track position and
balance changes induced by the strategy's trades. Second, given an
account we may evaluate the strategy's efficiency.

At the moment there are two ways to track strategy position and balance
changes:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \textbf{Virtual market order account}
  (\texttt{strategy.adaptive.VirtualMarket} class) listens orders issued
  by the strategy and for every order makes a request to the orderbook
  in order to estimate impact of trades produced by the order. At the
  moment correct estimation is done only for market orders
  (\texttt{request.EvalMarketOrder} is used) but order impact is
  estimated even if the strategy is suspended.
\item
  \textbf{Actually traded account}
  (\texttt{strategy.adaptive.ActuallyTraded} class) listens to
  \texttt{on\_traded} event of the strategy's trader and collects
  position and balance change produced by orders of this strategy. It
  allows to track impact of orders of any type but doesn't take into
  account orders issued by a suspended strategy.
\end{itemize}

Strategy efficiency can be estimated in different ways:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \textbf{Efficiency}: ``cleared'' trader's balance
  \texttt{eff = observable.Efficiency(}
  \texttt{                    strategy.adaptive.VirtualMarket(aStrategy))}
\item
  \textbf{Efficiency trend}: first derivative of some moving average of
  the trader's efficiency \texttt{ops.derivative(EWMA(eff, alpha))}
\item
  \textbf{Efficiency movements}: difference between the efficiency and
  its lagged value \texttt{eff - Lagged(eff, timeframe)}
\item
  \textbf{Scoring}: counting positive and negative movements of the
  effiency
\end{itemize}

\subsection{Trade-if-profitable
strategy}\label{trade-if-profitable-strategy}

Suspends an aggregated strategy if its effiency is estimated negatively.
By default, it uses \texttt{strategy.adaptive.VirtualMarket} as strategy
tracking account and efficiency trend as efficiency evaluator:

\begin{verbatim}
TradeIfProfitable(strategy,
                  account  = adaptive.virtualMarket,
                  performance = weight.efficiencyTrend) ::=

    efficiency = performance(account(strategy)) in
    Suspendable(strategy, efficiency >= 0)
\end{verbatim}

\centerline{\includegraphics[width=13cm]{Figures/web/tradeifprofitable.png}}

\subsection{Choose-the-best strategy}\label{choose-the-best-strategy}

This strategy aggregates an array of strategies and estimates their
efficiencies. At some moments of time it chooses a strategy with the
best performance and suspends others.

\centerline{\includegraphics[width=13cm]{Figures/web/choosethebest.png}}

\subsection{Multiarmed bandit
strategy}\label{multiarmed-bandit-strategy}

This strategy stores a weight for each aggregated strategy and regularly
updates it. Then it normilizes somehow the weights in order to choose
randomly a strategy. Choose-the-best strategy can be considered as a
particular case of the multiarmed bandit where the weight is equal
performance estimation of a strategy and normalization changes weight of
the best strategy to 1 and weights of other strategies are set to 0.

Multiarmed bandit has following parameters:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{strategies} -- array of strategies to aggregate
\item
  \texttt{account} -- function that creates an account tracking
  strategy's trades (\texttt{adaptive.VirtualMarket} or
  \texttt{adaptive.ActuallyTraded})
\item
  \texttt{weight} -- function calculating unnormalized weight of a
  strategy (like in trade-if-profitable or choose-the-best strategies)
\item
  \texttt{normalizer} -- function that transforms unnormalized weight
  (for example, to suit a certain range)
\item
  \texttt{corrector} -- function that takes an array of weights and
  makes their sum equal to 1
\end{itemize}

In the following figures position and efficiency of multiarmed bandit
strategies with different combination of these parameters are shown

\centerline{\includegraphics[width=13cm]{Figures/web/multiarmed-amount.png}}

\centerline{\includegraphics[width=13cm]{Figures/web/multiarmed-efficiency.png}}

\end{document}





